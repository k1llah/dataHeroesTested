import { watch as e, onMounted as i, onBeforeUnmount as a, defineComponent as t, ref as u, computed as c, openBlock as n, createElementBlock as r, normalizeStyle as s, unref as b, renderSlot as o } from "vue";
const l = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", easeInSine: "cubic-bezier(0.12, 0, 0.39, 0)", easeOutSine: "cubic-bezier(0.61, 1, 0.88, 1)", easeInOutSine: "cubic-bezier(0.37, 0, 0.63, 1)", easeInQuad: "cubic-bezier(0.11, 0, 0.5, 0)", easeOutQuad: "cubic-bezier(0.5, 1, 0.89, 1)", easeInOutQuad: "cubic-bezier(0.45, 0, 0.55, 1)", easeInCubic: "cubic-bezier(0.32, 0, 0.67, 0)", easeOutCubic: "cubic-bezier(0.33, 1, 0.68, 1)", easeInOutCubic: "cubic-bezier(0.65, 0, 0.35, 1)", easeInQuart: "cubic-bezier(0.5, 0, 0.75, 0)", easeOutQuart: "cubic-bezier(0.25, 1, 0.5, 1)", easeInOutQuart: "cubic-bezier(0.76, 0, 0.24, 1)", easeInQuint: "cubic-bezier(0.64, 0, 0.78, 0)", easeOutQuint: "cubic-bezier(0.22, 1, 0.36, 1)", easeInOutQuint: "cubic-bezier(0.83, 0, 0.17, 1)", easeInExpo: "cubic-bezier(0.7, 0, 0.84, 0)", easeOutExpo: "cubic-bezier(0.16, 1, 0.3, 1)", easeInOutExpo: "cubic-bezier(0.87, 0, 0.13, 1)", easeInCirc: "cubic-bezier(0.55, 0, 1, 0.45)", easeOutCirc: "cubic-bezier(0, 0.55, 0.45, 1)", easeInOutCirc: "cubic-bezier(0.85, 0, 0.15, 1)", easeInBack: "cubic-bezier(0.36, 0, 0.66, -0.56)", easeOutBack: "cubic-bezier(0.34, 1.56, 0.64, 1)", easeInOutBack: "cubic-bezier(0.68, -0.6, 0.32, 1.6)" }, z = t({ inheritAttrs: false, __name: "Vue3Collapse", props: { modelValue: { type: Boolean }, duration: { default: 500 }, easing: { default: "linear" }, withOpacity: { type: Boolean, default: true } }, setup(t2) {
  const z2 = t2, d = u();
  !function(t3, u2, c2) {
    function n2(e2, i2) {
      e2 && (i2 ? (e2.style.maxHeight = e2.scrollHeight + "px", c2.value && (e2.style.opacity = "1")) : (e2.style.maxHeight = "0px", c2.value && (e2.style.opacity = "0")));
    }
    let r2;
    function s2() {
      n2(t3.value, u2.value);
    }
    e(() => [u2.value, t3.value], ([e2, i2]) => {
      i2 && n2(i2, e2);
    }), i(() => {
      t3.value && (r2 = new MutationObserver(() => {
        n2(t3.value, u2.value);
      }), r2.observe(t3.value, { attributes: true, childList: true, characterData: true, subtree: true }), window.addEventListener("resize", s2));
    }), a(() => {
      r2 && r2.disconnect(), window.removeEventListener("resize", s2);
    });
  }(c(() => d.value), c(() => z2.modelValue), c(() => z2.withOpacity));
  const O = c(() => ({ overflow: "hidden", "transition-property": "all", "transition-timing-function": l[z2.easing], "transition-duration": `${z2.duration}ms` }));
  return (e2, i2) => (n(), r("div", { ref_key: "eleRef", ref: d, style: s(b(O)) }, [o(e2.$slots, "default")], 4));
} });
export {
  z as default
};
